"""
Low-rank probability density model for continuous distributions

"""

import numpy as np
import math
from scipy.stats import beta, randint 
from lowrankdensity.models.discrete import Discrete


class Continuous(Discrete):
    """Low-rank Bivariate Continuous Density Estimation
    
    Parameters 
    ----------
    alpha : float, default = 1
    Level of precision of density estimation

    Attributes :
    ---------
    density_function : function object 
    A density function for bivariate distributions with inputs x,y each a 1d array

    """

    L = 1
    
    def __init__(self,alpha=1):
        self.alpha = alpha 
        self.density_function = None

    def continuous_1d(self,Z,L=1):
        n = Z.shape[0]
        r = np.min(Z[:int(n/2)])
        R = np.max(Z[:int(n/2)])

        if (R - r < n**(-1/3)*L**(-1/2)):
            return lambda x : 1/(R-r) if (x<=r and x>=R) else 0

        else:
            h = math.floor((R-r)*n**(1/3)*L**(1/2))**(-1)*(R-r)
            E = np.arange(-math.floor(r/h), math.ceil((1-r)/h-1))

            def f(x):
                N = np.zeros((len(E)+1,))
                for i in range(int(n/2)+1,n):
                    N[int((Z[i] - r)/h)] += 1
            
                return (1/h)*N[int((x-r)/h)]

            return f
    

    def fit(self,X):
        """
        Fit the Bivariate Continuous Density model on the data


        Parameters :
        ----------
        X : np.array of shape (n,2)
        A numpy array generated by a joint continuous distribution 

    
        Return :
        ---------
        self : object
        Returns the instance itself.
    
        """

        if not isinstance(X, np.ndarray):
            raise TypeError(f"Input X should be a nd.array, not a {type(X)}")
        
        if X.shape[0] == 0:
            raise ValueError("X is an empty array")

        if self.alpha < 0:
            raise ValueError(f"alpha should be positive")
        
        if type(self.alpha) not in (int,float):
            raise TypeError(f"alpha should be a float, not {type(self.alpha)}")
    
        n = X.shape[0]
        L = self.L
        r1, R1 = np.min(X[:int(n/2),0]), np.max(X[:int(n/2),0])
        r2, R2 = np.min(X[:int(n/2),1]), np.max(X[:int(n/2),1])

        if R1 - r1 < n**(-1/3)*L**(-1/2):
            g = self.continuous_1d(Z=X[int(n/2+1):,1])
            self.density_function = lambda x,y : (1/(R1 - r1))*g(y) if (r1 <= x < R1) else 0 
            return self

        if R2 - r2 < n**(-1/3)*L**(-1/2):
            g = self.continuous_1d(Z=X[int(n/2+1):,0])
            self.density_function = lambda x,y : (1/(R2 - r2))*g(x) if (r2 <= y < R2) else 0 
            return self
  
        h1 = math.floor((R1-r1)*n**(1/3)*L**(1/2))**(-1)*(R1-r1)
        h2 = math.floor((R2-r2)*n**(1/3)*L**(1/2))**(-1)*(R2-r2)
        
        E1 = np.arange(-math.floor(r1/h1),math.ceil((1-r1)/h1-1))
        E2 = np.arange(-math.floor(r2/h2),math.ceil((1-r2)/h2-1))
        
        N1 = np.zeros((len(E1)+1,len(E2)+1))
        N2 = np.zeros((len(E1)+1,len(E2)+1))

        for i,j in zip(range(int(n/2)+1, int(3*n/4)),range(int(3*n/4)+1, n)):
            x1, y1 = X[i,:]
            x2, y2 = X[j,:]
        
            N1[int((x1 - r1)/h1),int((y1 - r2)/h2)] = N1[int((x1 - r1)/h1),int((y1 - r2)/h2)] + 1
            N2[int((x2 - r1)/h1),int((y2 - r2)/h2)] = N2[int((x2 - r1)/h1),int((y2 - r2)/h2)] + 1

        P = super()._compute_matrix(n=int(n/2), Y1=N1, Y2=N2, discrete=False)        
        m1 = math.floor((R1-r1)*n**(1/3)*L**(1/2)) 
        m2 = math.floor((R2-r2)*n**(1/3)*L**(1/2))

        def f(x,y): 
            x1, y1 = int((x - r1)/h1), int((y - r2)/h2)
            if 0 <= x1 < m1 and 0 <= y1 < m2:
                return (1/(h1*h2))*P[x1,y1]
            else:
                return (1/(h1*h2))*(2/n)*(N1[x1,y1] + N2[x1,y1])
     
        self.density_function = f
        return None
        

    def pdf(self,x,y):
        """
        Compute the estimated low-rank probability density function 

        Parameters 
        ---------
        x : nd.array 
        2D array 
        

        Return 
        ---------
        mat : nd.array of shape (len(x),len(y))
        Matrix with computed density function values for inputs x and y

        """
        if not isinstance(x,np.ndarray):
            raise TypeError(f"x should be a nd.array, not a {type(x)}")
        
        if not isinstance(y,np.ndarray):
            raise TypeError(f"y should be a nd.array, not a {type(y)}")

        funs = self.density_function

        return  np.array([[funs(i,j) for j in y] for i in x])
    

    # def sample(self,):
    #     N, M = 10, 10
    #     A = np.arange(N)
    #     B = np.arange(M)
    


