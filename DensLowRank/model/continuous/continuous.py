"""
Low-rank probability density function estimator for continuous distributions

Author : Laurène David 
"""

import numpy as np
import math
#import DensLowRank.model.discrete *
from scipy.stats import beta, randint 
# import sys
# sys.path.append('C:\\Users\\LaurèneDAVID\\Documents\\Projects\\Dimension_Reduction\\DensLowRank_repo\\DensLowRank\\model\\discrete')
from discrete import Discrete




class Continuous(Discrete):
    """Low-rank Bivariate Continuous Density Estimation
    
    Parameters 
    ----------
    alpha : float, default=0.1
    Level of precision of density estimation

    
    Attributes :
    ---------
    density_function : python function 
    A density function for bivariate distributions 
    with inputs x,y each a 1d array

    """

    L = 1
    
    def __init__(self,alpha=0.1):
        self.alpha = alpha 
        self.density_function = None

    def continuous_1d(self,Z,L=1):
        n = Z.shape[0]
        r = np.min(Z[:int(n/2)])
        R = np.max(Z[:int(n/2)])

        if (R - r < n**(-1/3)*L**(-1/2)):
            return lambda x : 1/(R-r) if (x<=r and x>=R) else 0

        else:
            h = math.floor((R-r)*n**(1/3)*L**(1/2))**(-1)*(R-r)
            E = np.arange(-math.floor(r/h), math.ceil((1-r)/h-1))

            def f(x):
                N = np.zeros((len(E)+1,))
                for i in range(int(n/2)+1,n):
                    N[int((Z[i] - r)/h)] += 1
            
                return (1/h)*N[int((x-r)/h)]

            return f
    

    def fit(self,X):
        """
        Fit the Bivariate Continuous Density model on the data


        Parameters :
        ----------
        X : np.array of shape (n,2)
        A numpy array generated by a joint continuous distribution 

    
        Return :
        ---------
        self : object
        Returns the instance itself.
    
        """

        if not isinstance(X, np.ndarray):
            raise TypeError(f"Input X should be a nd.array, not a {type(X)}")
        
        if X.shape[0] == 0:
            raise ValueError("X is an empty array")

        if self.alpha < 0:
            raise ValueError(f"alpha should be positive")
        
        if type(self.alpha) not in (int,float):
            raise TypeError(f"alpha should be a float, not {type(self.alpha)}")
        

        n = X.shape[0]
        L = self.L
        r1, R1 = np.min(X[:int(n/2),0]), np.max(X[:int(n/2),0])
        r2, R2 = np.min(X[:int(n/2),1]), np.max(X[:int(n/2),1])

        if R1 - r1 < n**(-1/3)*L**(-1/2):
            g = self.continuous_1d(Z=X[int(n/2+1):,1])
            self.density_function = lambda x,y : (1/(R1 - r1))*g(y) if (r1 <= x < R1) else 0 
            return self

        if R2 - r2 < n**(-1/3)*L**(-1/2):
            g = self.continuous_1d(Z=X[int(n/2+1):,0])
            self.density_function = lambda x,y : (1/(R2 - r2))*g(x) if (r2 <= y < R2) else 0 
            return self
  
        h1 = math.floor((R1-r1)*n**(1/3)*L**(1/2))**(-1)*(R1-r1)
        h2 = math.floor((R2-r2)*n**(1/3)*L**(1/2))**(-1)*(R2-r2)
        
        E1 = np.arange(-math.floor(r1/h1),math.ceil((1-r1)/h1-1))
        E2 = np.arange(-math.floor(r2/h2),math.ceil((1-r2)/h2-1))
        
        N1 = np.zeros((len(E1)+1,len(E2)+1))
        N2 = np.zeros((len(E1)+1,len(E2)+1))

        for i,j in zip(range(int(n/2)+1, int(3*n/4)),range(int(3*n/4)+1, n)):
            x1, y1 = X[i,:]
            x2, y2 = X[j,:]
        
            N1[int((x1 - r1)/h1),int((y1 - r2)/h2)] = N1[int((x1 - r1)/h1),int((y1 - r2)/h2)] + 1
            N2[int((x2 - r1)/h1),int((y2 - r2)/h2)] = N2[int((x2 - r1)/h1),int((y2 - r2)/h2)] + 1

        P = super()._compute_matrix(n=int(n/2), Y1=N1, Y2=N2, discrete_case=False)        
        m1 = math.floor((R1-r1)*n**(1/3)*L**(1/2)) 
        m2 = math.floor((R2-r2)*n**(1/3)*L**(1/2))

        def f(x,y): 
            x1, y1 = int((x - r1)/h1), int((y - r2)/h2)
            if 0 <= x1 < m1 and 0 <= y1 < m2:
                return (1/(h1*h2))*P[x1,y1]
            else:
                return (1/(h1*h2))*(2/n)*(N1[x1,y1] + N2[x1,y1])
     
        self.density_function = f
        return self
        


    def pdf(self,x,y):
        """
        Compute the estimated low-rank probability density function 

        Parameters 
        ---------
        x : nd.array 
        1D array 

        y : nd.array 
        1D array

        
        Return 
        ---------
        mat : nd.array of shape (len(x),len(y))
        Matrix with computed density function values for inputs x and y

        """
        if not isinstance(x,np.ndarray):
            raise TypeError(f"x should be a nd.array, not a {type(X)}")
        
        if not isinstance(y,np.ndarray):
            raise TypeError(f"y should be a nd.array, not a {type(X)}")
        

        funs = self.density_function
        mat = np.zeros((len(x),len(y)))
        
        for i in range(len(x)):
            for j in range(len(y)):
                mat[i,j] = funs(x[i],y[j])
        
        return mat
    



### Test Continuous model with continuous test data #####

# np.random.seed(1)

# # Sample data
# n_samples = 20000
# K = 8

# a1 = np.linspace(1,2,K)
# a2 = np.linspace(1.5,2,K) 
# b1 = np.linspace(1,1.5,K) 
# b2 = np.linspace(1,2,K) 

# f = [beta(a=a1[j],b=b1[j]) for j in range(K)]
# g = [beta(a=a2[j],b=b2[j]) for j in range(K)]

# def sample_data(n,K):
#     mat = np.zeros((n,2))
#     for i in range(n):
#         j = randint(low=0,high=K-1).rvs()
#         X = f[j].rvs()
#         Y = g[j].rvs()
#         mat[i,:] = np.array([X,Y])
#     return mat

# samples = sample_data(n=n_samples,K=K)


# # Use Continuous class
# model = Continuous(alpha=0.1)
# model.fit(X=samples)

# x = np.linspace(0,1)
# y = np.linspace(0,1)
# density_funs = model.pdf(x,y) 

# print(density_funs)

